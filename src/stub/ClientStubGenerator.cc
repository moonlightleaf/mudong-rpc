#include "stub/ClientStubGenerator.hpp"

using namespace mudong::rpc;

namespace {

std::string clientStubTemplate(
        const std::string& macroName,
        const std::string& stubClassName,
        const std::string& procedureDefinitions,
        const std::string& notifyDefinitions)
{
    std::string str = R"(
/*
 * This stub is generated by mudong-rpc, DO NOT modify it!
 */

#pragma once

#include <mudong-json/include/Value.hpp>

#include "utils/util.hpp"
#include "client/BaseClient.hpp"

namespace mudong {

namespace rpc {

class [stubClassName]: noncopyable {

public:
    [stubClassName](EventLoop* loop, const InetAddress& serverAddress):
            client_(loop, serverAddress)
    {
        client_.setConnectionCallback([this](const TcpConnectionPtr& conn){
            if (conn->connected()) {
                INFO("connected");
                conn_ = conn;
                cb_(conn_);
            }
            else {
                INFO("disconnected");
                assert(conn_ != nullptr);
                cb_(conn_);
            }
        });
    }

    ~[stubClassName]() = default;

    void start() { client_.start(); }

    void setConnectionCallback(const ConnectionCallback& cb)
    {
        cb_ = cb;
    }

    [procedureDefinitions]
    [notifyDefinitions]

private:
    TcpConnectionPtr conn_;
    ConnectionCallback cb_;
    BaseClient client_;
};

} // namespace rpc

} // namespce mudong
)";
    replaceAll(str, "[macroName]", macroName);
    replaceAll(str, "[stubClassName]", stubClassName);
    replaceAll(str, "[procedureDefinitions]", procedureDefinitions);
    replaceAll(str, "[notifyDefinitions]", notifyDefinitions);
    return str;
}

std::string procedureDefineTemplate(
        const std::string& serviceName,
        const std::string& procedureName,
        const std::string& procedureArgs,
        const std::string& paramMembers)

{
    std::string str = R"(
void [procedureName]([procedureArgs] const ResponseCallback& cb) {
    mudong::json::Value params(mudong::json::ValueType::TYPE_OBJECT);
    [paramMembers]

    mudong::json::Value call(mudong::json::ValueType::TYPE_OBJECT);
    call.addMember("jsonrpc", "2.0");
    call.addMember("method", "[serviceName].[procedureName]");
    call.addMember("params", params);

    assert(conn_ != nullptr);
    client_.sendCall(conn_, call, cb);
}
)";
    replaceAll(str, "[serviceName]", serviceName);
    replaceAll(str, "[procedureName]", procedureName);
    replaceAll(str, "[procedureArgs]", procedureArgs);
    replaceAll(str, "[paramMembers]", paramMembers);
    return str;
}

std::string notifyDefineTemplate(
        const std::string& serviceName,
        const std::string& notifyName,
        const std::string& notifyArgs,
        const std::string& paramMembers)
{
    std::string str = R"(
void [notifyName]([notifyArgs]) {
    mudong::json::Value params(mudong::json::ValueType::TYPE_OBJECT);
    [paramMembers]

    mudong::json::Value notify(mudong::json::ValueType::TYPE_OBJECT);
    notify.addMember("jsonrpc", "2.0");
    notify.addMember("method", "Hello.Goodbye");

    assert(conn_ != nullptr);
    client_.sendNotify(conn_, notify);
}
)";
    replaceAll(str, "[serviceName]", serviceName);
    replaceAll(str, "[notifyName]", notifyName);
    replaceAll(str, "[notifyArgs]", notifyArgs);
    replaceAll(str, "[paramMembers]", paramMembers);
    return str;
}

std::string paramMemberTemplate(const std::string& paramName) {
    std::string str = R"(
params.addMember("[paramName]", [paramName]);
)";
    replaceAll(str, "[paramName]", paramName);
    return str;
}

std::string argTemplate(
        const std::string& argName,
        mudong::json::ValueType argType)
{
    std::string str = R"([argType] [argName])";
    auto typeStr = [=](){
        switch (argType) {
            case mudong::json::ValueType::TYPE_INT32:
                return "int32_t";
            case mudong::json::ValueType::TYPE_INT64:
                return "int64_t";
            case mudong::json::ValueType::TYPE_DOUBLE:
                return "double";
            case mudong::json::ValueType::TYPE_BOOL:
                return "bool";
            case mudong::json::ValueType::TYPE_STRING:
                return "std::string";
            case mudong::json::ValueType::TYPE_OBJECT:
            case mudong::json::ValueType::TYPE_ARRAY:
                return "mudong::json::Value";
            default:
                assert(false && "bad arg type");
                return "bad type";
        }
    }();
    replaceAll(str, "[argType]", typeStr);
    replaceAll(str, "[argName]", argName);
    return str;
}

} // anonymous namespace

std::string ClientStubGenerator::genStub() {
    auto macroName = genMacroName();
    auto stubClassName = genStubClassName();
    auto procedureDefinitions = genProcedureDefinitions();
    auto notifyDefinitions = genNotifyDefinitions();

    return clientStubTemplate(macroName, stubClassName, procedureDefinitions, notifyDefinitions); 
}

std::string ClientStubGenerator::genMacroName() {
    std::string result = serviceInfo_.name;
    for (char& c : result) {
        c = static_cast<char>(toupper(c));
    }
    return result + "CLIENTSTUB";
}

std::string ClientStubGenerator::genStubClassName() {
    return serviceInfo_.name + "ClientStub";
}

std::string ClientStubGenerator::genProcedureDefinitions() {
    std::string result;

    auto& serviceName = serviceInfo_.name;

    for (auto& r : serviceInfo_.rpcReturn) {
        auto& procedureName = r.name;
        auto  procedureArgs = genGenericArgs(r, true);
        auto  paramMembers = genGenericParamMembers(r);

        auto str = procedureDefineTemplate(
                serviceName,
                procedureName,
                procedureArgs,
                paramMembers);
        result.append(str);
    }
    return result;
}

std::string ClientStubGenerator::genNotifyDefinitions() {
    std::string result;

    auto& serviceName = serviceInfo_.name;

    for (auto& r : serviceInfo_.rpcNotify) {
        auto& notifyName = r.name;
        auto notifyArgs = genGenericArgs(r, false);
        auto paramMembers = genGenericParamMembers(r);

        auto str = notifyDefineTemplate(
                serviceName,
                notifyName,
                notifyArgs,
                paramMembers);
        result.append(str);
    }
    return result;
}

template <typename Rpc>
std::string ClientStubGenerator::genGenericArgs(const Rpc& r, bool appendComma) {
    std::string result;
    bool first = true;
    for (auto& p : r.params.getObject()) {
        std::string one = argTemplate(p.key.getString(),
                                      p.value.getType());
        if (first) {
            first = false;
        }
        else {
            result.append(", ");
        }
        result.append(one);
    }
    if (appendComma && !first)
        result.append(",");
    return result;
}

template <typename Rpc>
std::string ClientStubGenerator::genGenericParamMembers(const Rpc& r) {
    std::string result;
    for (auto& p : r.params.getObject()) {
        std::string one = paramMemberTemplate(
                p.key.getString());
        result.append(one);
    }
    return result;
}